---
interface Props {
    data: number[];
}

const { data } = Astro.props;

const width = 200;
const height = 50;

const max = Math.max(...data);
const min = Math.min(...data);
// Avoid division by zero
const range = max - min || 1;

/**
 * Build point objects
 */
const points = data.map((d, i) => {
    const x = (i / (data.length - 1)) * width;
    // Invert y because SVG y=0 is top
    const y = height - ((d - min) / range) * height;
    return { x, y };
});

/**
 * Quadratic BÃ©zier smoothing
 */
function smoothLinePath(points: { x: number; y: number }[]): string {
    if (points.length < 2) return "";

    const d: string[] = [];
    d.push(`M ${points[0]!.x} ${points[0]!.y}`);

    for (let i = 1; i < points.length - 1; i++) {
        const xc = (points[i]!.x + points[i + 1]!.x) / 2;
        const yc = (points[i]!.y + points[i + 1]!.y) / 2;
        d.push(`Q ${points[i]!.x} ${points[i]!.y} ${xc} ${yc}`);
    }

    // Smoothly connect to last point
    const last = points[points.length - 1]!;
    d.push(`T ${last.x} ${last.y}`);

    return d.join(" ");
}

const linePath = smoothLinePath(points);

/**
 * Area path based on the smooth line
 */
const areaPath = `
  ${linePath}
  L ${width} ${height}
  L 0 ${height}
  Z
`;
---

<svg
    width="100%"
    height="66%"
    viewBox={`0 0 ${width} ${height}`}
    preserveAspectRatio="none"
    class="sparkline-svg pointer-events-none"
>
    <defs>
        <linearGradient id="gradient" x1="0" x2="0" y1="0" y2="1">
            <stop offset="0%" stop-color="currentColor" stop-opacity="0.2"></stop>
            <stop offset="100%" stop-color="currentColor" stop-opacity="0"></stop>
        </linearGradient>
    </defs>

    <!-- Area -->
    <path d={areaPath} fill="url(#gradient)" stroke="none"></path>

    <!-- Line -->
    <path d={linePath} fill="none" stroke="currentColor" stroke-opacity="0.25" stroke-width="2"
    ></path>
</svg>

<style>
    .sparkline-svg {
        overflow: visible;
    }
</style>
